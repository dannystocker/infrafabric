---
# Unified SIP Adapter Pattern - IF.connect Protocol Implementation
# Design specification for 7 SIP server adapters

metadata:
  title: "Unified SIPAdapter Base Class Pattern"
  version: "1.0.0"
  timestamp: "2025-11-11T00:00:00Z"
  phase: "Architecture (Agent 8 - IF.search discovery)"
  scope: "Design pattern for 7 SIP adapters: Asterisk, FreeSWITCH, Kamailio, OpenSIPS, Yate, PJSUA, SIPp"
  philosophy: "Confucian Wu Lun (五伦) relationship mapping for SIP call hierarchy"

---

## Executive Summary

This document specifies a unified `SIPAdapter` base class that all 7 SIP server adapters will inherit from. The pattern ensures:

- **Consistency:** Identical interface across heterogeneous SIP implementations
- **Reliability:** Built-in retry logic, connection pooling, health checks
- **Observability:** Event-driven architecture with callback hooks
- **Compliance:** IF.TTT (Traceable/Transparent/Trustworthy) protocol integration
- **Extensibility:** Clean abstract methods for adapter-specific implementations

---

## 1. Architecture Overview

### 1.1 Layer Model

```
┌─────────────────────────────────────────────┐
│  Application Layer (Call Management)        │  User code
├─────────────────────────────────────────────┤
│  SIPAdapter (Concrete Implementations)      │  7 adapters
├─────────────────────────────────────────────┤
│  SIPAdapterBase (Abstract Base Class)       │  THIS DESIGN
├─────────────────────────────────────────────┤
│  SIPProtocol (RFC 3261 Interface)           │  Protocol layer
├─────────────────────────────────────────────┤
│  Network I/O (TCP/UDP/TLS)                  │  Transport
└─────────────────────────────────────────────┘
```

### 1.2 Component Responsibilities

| Component | Responsibility | Ownership |
|-----------|-----------------|-----------|
| `SIPAdapterBase` | Interface definition, shared utilities | Agent 8 (this design) |
| `AsteriskAdapter` | Asterisk AMI protocol mapping | Agent 1 |
| `FreeSwitchAdapter` | FreeSWITCH ESL protocol mapping | Agent 2 |
| `KamailioAdapter` | Kamailio MI (Management Interface) | Agent 3 |
| `OpenSIPSAdapter` | OpenSIPS MI + MI_JSON | Agent 4 |
| `YateAdapter` | Yate telephony engine interface | Agent 5 |
| `PJSUAAdapter` | PJSUA2 library integration | Agent 6 |
| `SIPpAdapter` | SIPp traffic generator (testing) | Agent 7 |

---

## 2. Interface Specification

### 2.1 Required Methods (Must Implement)

Every adapter MUST implement these core methods:

```
┌─────────────────────────────────────────────────────────────┐
│ connect(host: str, port: int, auth_config: Dict) → bool     │
│ Establish connection to SIP server                            │
├─────────────────────────────────────────────────────────────┤
│ disconnect() → bool                                           │
│ Gracefully terminate connection, cleanup resources            │
├─────────────────────────────────────────────────────────────┤
│ make_call(from_number, to_number, options) → str (call_id)   │
│ Initiate outbound SIP call                                   │
├─────────────────────────────────────────────────────────────┤
│ hangup(call_id: str) → bool                                  │
│ Terminate active call                                        │
├─────────────────────────────────────────────────────────────┤
│ get_status(call_id: str) → Dict                              │
│ Query current call state and metrics                         │
├─────────────────────────────────────────────────────────────┤
│ health_check() → Dict                                        │
│ Return connection status and adapter metrics                 │
├─────────────────────────────────────────────────────────────┤
│ validate_config(config: Dict) → bool                         │
│ Verify configuration schema and values                       │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Optional Methods (May Implement)

Adapters may override for advanced features:

```
┌─────────────────────────────────────────────────────────────┐
│ transfer(call_id, destination, options) → bool               │
│ Blind or attended call transfer                              │
├─────────────────────────────────────────────────────────────┤
│ hold(call_id) → bool                                         │
│ Place call on hold                                           │
├─────────────────────────────────────────────────────────────┤
│ resume(call_id) → bool                                       │
│ Resume held call                                             │
├─────────────────────────────────────────────────────────────┤
│ conference(call_ids: List[str]) → str (conference_id)        │
│ Merge multiple calls into conference                         │
├─────────────────────────────────────────────────────────────┤
│ record(call_id, format, options) → bool                      │
│ Record call audio                                            │
├─────────────────────────────────────────────────────────────┤
│ get_call_history(limit: int) → List[Dict]                    │
│ Retrieve recent call history                                 │
├─────────────────────────────────────────────────────────────┤
│ get_cdr(call_id: str) → Dict                                 │
│ Retrieve Call Detail Record (CDR)                            │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Callback System

Adapters register event handlers for async notifications:

```python
# Callback signature
def on_call_state_changed(event: CallStateEvent) -> None:
    """
    Raised when call state changes (ringing, connected, disconnected, etc.)

    event.call_id: str
    event.state: str  # "ringing" | "connected" | "disconnected" | "failed"
    event.timestamp: float
    event.details: Dict  # Protocol-specific details
    """
    pass

def on_incoming_call(event: IncomingCallEvent) -> None:
    """
    Raised when new inbound call arrives

    event.from_number: str
    event.to_number: str
    event.call_id: str
    event.accept_callback: Callable[[], bool]
    event.reject_callback: Callable[[], bool]
    """
    pass

def on_error(event: ErrorEvent) -> None:
    """
    Raised when protocol-level error occurs

    event.error_code: int
    event.error_message: str
    event.severity: str  # "warning" | "error" | "critical"
    event.call_id: str (optional)
    """
    pass

def on_connection_state_changed(event: ConnectionStateEvent) -> None:
    """
    Raised when adapter connection state changes

    event.connected: bool
    event.reason: str
    event.retry_count: int
    """
    pass
```

---

## 3. Configuration Schema

### 3.1 Required Configuration Fields

```yaml
config:
  type: "asterisk"  # One of: asterisk, freeswitch, kamailio, opensips, yate, pjsua, sipp
  host: "192.168.1.100"
  port: 5060

  auth:
    username: "admin"
    password: "secret"
    realm: "example.com"  # SIP realm/domain

  tls_enabled: false
  tls_cert_path: null
  tls_key_path: null
  tls_ca_path: null
  tls_verify: true
```

### 3.2 Optional Configuration Fields

```yaml
config:
  # Connection management
  timeout: 30  # seconds, default 30
  retry_count: 3
  retry_backoff_base: 2  # exponential backoff multiplier
  retry_max_delay: 300  # max 5 minutes between retries

  # Connection pooling
  pool_size: 10  # max concurrent connections
  connection_ttl: 3600  # seconds, recycle old connections

  # Call behavior
  ring_timeout: 60  # seconds before call timeout
  dtmf_mode: "rfc2833"  # or "info", "sip_info"
  user_agent: "InfraFabric/1.0"

  # Logging & observability
  log_level: "INFO"  # DEBUG, INFO, WARNING, ERROR, CRITICAL
  enable_sip_trace: false
  enable_metrics: true

  # Adapter-specific overrides (preserved in dict)
  adapter_config: {}
```

### 3.3 Configuration Validation Rules

```
✓ type must be one of: [asterisk, freeswitch, kamailio, opensips, yate, pjsua, sipp]
✓ host must be valid IP address or resolvable hostname
✓ port must be in range [1024, 65535]
✓ auth.username required, non-empty string
✓ auth.realm required, valid SIP domain
✓ timeout must be > 0
✓ retry_count must be >= 0
✓ pool_size must be in range [1, 100]
✓ tls_enabled: if true, tls_cert_path and tls_key_path required
✗ tls_enabled and port 5060 is suspicious (should use 5061 for TLS)
```

---

## 4. Shared Utilities

### 4.1 Retry Logic with Exponential Backoff

```python
def retry_with_backoff(
    func: Callable,
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 300.0,
    on_retry: Optional[Callable[[int, Exception], None]] = None
) -> Any:
    """
    Execute function with exponential backoff retry.

    Formula: delay = min(base_delay * (backoff_base ^ attempt), max_delay)

    Example: base_delay=1, backoff_base=2
      Attempt 1: 1s
      Attempt 2: 2s
      Attempt 3: 4s
      Attempt 4: 8s
      Attempt 5: 16s (capped at max_delay)
    """
    pass
```

### 4.2 Connection Pool Management

```python
class ConnectionPool:
    """
    Thread-safe connection pool with automatic recycling.

    Features:
    - Lazy initialization (create on first use)
    - TTL-based connection recycling (close stale connections)
    - Size limits (max_size parameter)
    - Health checking (verify connection before returning)
    """

    def __init__(self, max_size: int, connection_ttl: int):
        pass

    def acquire(self) -> Connection:
        """Get connection from pool, create if needed."""
        pass

    def release(self, conn: Connection) -> None:
        """Return connection to pool."""
        pass

    def health_check_all(self) -> Dict[str, bool]:
        """Verify all pooled connections are still valid."""
        pass
```

### 4.3 Response Parser

```python
def parse_response(raw_data: Union[str, bytes]) -> Dict[str, Any]:
    """
    Parse adapter-specific response format into canonical format.

    Handles:
    - SIP message parsing (200 OK, 403 Forbidden, etc.)
    - Key-value responses (Asterisk AMI format)
    - JSON responses (OpenSIPS MI_JSON)
    - Custom formats (delegate to adapter via override)

    Returns:
    {
        "status": "success" | "error",
        "code": 200,  # HTTP-like status code
        "message": "descriptive text",
        "data": {...}  # Response payload
    }
    """
    pass
```

### 4.4 Event Emitter

```python
class EventEmitter:
    """
    Async event bus with callback registration.

    Features:
    - Multiple handlers per event
    - Error isolation (one failing callback doesn't affect others)
    - Async/sync callback support
    - Event filtering by pattern
    """

    def on(self, event_type: str, callback: Callable) -> None:
        """Register callback for event type."""
        pass

    def off(self, event_type: str, callback: Callable) -> None:
        """Unregister callback."""
        pass

    def emit(self, event_type: str, event_data: Dict) -> None:
        """Fire event to all registered callbacks."""
        pass
```

### 4.5 Error Handling & Recovery

```python
class SIPAdapterError(Exception):
    """Base exception for all adapter errors."""
    code: int
    severity: str  # "warning" | "error" | "critical"
    retryable: bool

class ConnectionError(SIPAdapterError):
    """Connection-level errors (retryable)."""
    pass

class CallError(SIPAdapterError):
    """Call-level errors (may be retryable)."""
    pass

class ConfigurationError(SIPAdapterError):
    """Configuration validation errors (not retryable)."""
    pass

class TimeoutError(SIPAdapterError):
    """Operation timeout (retryable)."""
    pass
```

---

## 5. Call State Machine

All adapters must support this standard call state machine:

```
                    ┌─────────────┐
                    │   Created   │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │   Dialing   │
                    └──────┬──────┘
                           │
                ┌──────────┼──────────┐
                │                     │
         ┌──────▼──────┐      ┌──────▼──────┐
         │   Ringing   │      │   Incoming  │
         └──────┬──────┘      └──────┬──────┘
                │                     │
         ┌──────▼──────────────────────┐
         │        Connected            │
         └──────┬──────────────┬───────┘
                │              │
         ┌──────▼──┐      ┌────▼─────┐
         │   On Hold   │      │ Transferring│
         └──────┬──┘      └────┬─────┘
                │              │
                └──────┬───────┘
                       │
                ┌──────▼──────┐
                │   Hanging up│
                └──────┬──────┘
                       │
                ┌──────▼──────┐
                │  Terminated │
                └─────────────┘

Allowed transitions:
- Created → Dialing
- Dialing → Ringing, Connected, Terminated
- Ringing → Connected, Terminated
- Incoming → Connected, Terminated
- Connected → On Hold, Transferring, Hanging up
- On Hold → Connected, Hanging up
- Transferring → Connected (for receiving leg), Terminated
- Hanging up → Terminated
```

---

## 6. Wu Lun (五伦) Relationship Mapping for SIP

Based on Confucian Wu Lun framework, map SIP call hierarchy to relationships:

```python
wu_lun_mapping = {
    "君臣": {
        "name": "Ruler-Subject",
        "applies_to": "Call initiator → SIP server",
        "weight": 0.95,
        "properties": ["authority", "accountability"]
    },
    "父子": {
        "name": "Parent-Child",
        "applies_to": "Master call → Transferred call",
        "weight": 0.85,
        "properties": ["protection", "guidance"]
    },
    "夫婦": {
        "name": "Spouse (Husband-Wife)",
        "applies_to": "Call legs in conference",
        "weight": 0.80,
        "properties": ["cooperation", "symmetry"]
    },
    "兄弟": {
        "name": "Siblings",
        "applies_to": "Peer SIP adapters",
        "weight": 0.75,
        "properties": ["mutual respect", "collaboration"]
    },
    "朋友": {
        "name": "Friends",
        "applies_to": "Call agents (human operators)",
        "weight": 0.70,
        "properties": ["trust", "voluntary"]
    }
}
```

**Application:**
- Use relationship weights to determine call priority in queue
- Apply relationship-specific error recovery strategies
- Implement role-specific permissions (e.g., only "君" can terminate calls)

---

## 7. Health Check Interface

Every adapter must expose health status:

```python
def health_check() -> Dict[str, Any]:
    """
    Return comprehensive health metrics.

    Returns:
    {
        "adapter": "asterisk",
        "connected": True,
        "uptime_seconds": 3600,
        "metrics": {
            "active_calls": 5,
            "call_attempts": 142,
            "call_success_rate": 0.94,
            "avg_call_duration": 245,
            "connection_failures": 0,
            "last_error": None,
            "pool_utilization": 0.5,  # 5/10 connections in use
        },
        "latency": {
            "min_ms": 12,
            "max_ms": 156,
            "avg_ms": 45
        },
        "last_check": "2025-11-11T10:30:45Z",
        "status": "healthy"  # "healthy" | "degraded" | "critical"
    }
    """
    pass
```

**Health Status Criteria:**
- `healthy`: Connected, <5% failure rate, avg latency <100ms
- `degraded`: Connected, 5-20% failure rate OR avg latency 100-300ms
- `critical`: Not connected OR >20% failure rate OR latency >300ms

---

## 8. Thread Safety & Concurrency

The adapter must be **thread-safe** for:

1. **Multiple outbound calls** (concurrent `make_call()`)
2. **Async callbacks** (event handlers from network thread)
3. **Connection pool access** (acquire/release from multiple threads)
4. **Metrics updates** (concurrent metric increments)

**Implementation Requirements:**
- Use `threading.Lock` or `asyncio.Lock` for shared state
- Document which methods are async-safe
- Provide both sync and async interfaces

---

## 9. IF.TTT Protocol Integration

All adapters must comply with IF.TTT (Traceable/Transparent/Trustworthy):

### 9.1 Traceable

Each call must include provenance:

```python
{
    "call_id": "if://call/uuid-1234",
    "request_id": "if://request/trace-id",
    "source_agent": "Agent-8-SIP-Manager",
    "timestamp": "2025-11-11T10:30:45.123Z",
    "originated_from": "if://agent/orchestrator/id"
}
```

### 9.2 Transparent

All operations logged with full context:

```
[2025-11-11 10:30:45] CALL_INITIATED call_id=xxx from=+1234567890 to=+0987654321
[2025-11-11 10:30:46] CALL_RINGING call_id=xxx elapsed=1.2s
[2025-11-11 10:30:52] CALL_CONNECTED call_id=xxx duration=7.1s
[2025-11-11 10:31:15] CALL_DISCONNECTED call_id=xxx total=30.1s reason=user_hangup
```

### 9.3 Trustworthy

All metrics cryptographically signed:

```python
{
    "metrics": {
        "active_calls": 5,
        "success_rate": 0.94
    },
    "signature": {
        "alg": "ed25519",
        "pubkey": "...",
        "sig": "..."
    }
}
```

---

## 10. Error Handling Strategy

```
Error Type              Retryable?    Recovery Action
─────────────────────────────────────────────────────
Connection timeout      Yes           Retry with backoff
DNS resolution fail     Yes           Retry with new resolution
TLS handshake fail      No            Log + escalate
Auth failure            No            Fail immediately
Invalid config          No            Reject at startup
Call rejection (SIP 486)Maybe         Check network state
Network unreachable     Yes           Retry later
Call hangup by remote   No            Clean up local state
RTP timeout (no audio)  Maybe         Attempt reconnect
Invalid call_id         No            Return error
```

---

## 11. Concrete Adapter Requirements

Each of the 7 adapters must implement:

### Asterisk (Agent 1)
- Connect via AMI (Asterisk Manager Interface) on port 5038
- Parse AMI responses (key-value format)
- Map Asterisk call variables to canonical format
- Handle AMI-specific events (VarSet, Newchannel, Hangup)

### FreeSWITCH (Agent 2)
- Connect via ESL (Event Socket Library) on port 8021
- Parse ESL events and responses
- Handle UUID-based call tracking
- Implement FreeSWITCH session management

### Kamailio (Agent 3)
- Connect via MI (Management Interface) on port 5060+
- Support MI RPC protocol
- Implement dialog tracking via MI
- Handle user location service

### OpenSIPS (Agent 4)
- Connect via MI or MI_JSON on port 8888
- Parse JSON-RPC responses
- Implement OpenSIPS-specific commands
- Handle dynamic routing

### Yate (Agent 5)
- Connect via TCP socket on port 5039
- Parse Yate message format
- Handle Yate routing rules
- Implement Yate-specific features

### PJSUA (Agent 6)
- Use PJSUA2 C++ library binding
- Implement call factory pattern
- Handle codec negotiation
- Manage registration with registrar

### SIPp (Agent 7)
- Connect via HTTP REST API (default port 8080)
- Parse SIPp traffic reports
- Implement scenario-based call generation
- Handle load testing features

---

## 12. Testing Strategy

Each adapter must pass:

```
1. Unit Tests
   - Config validation
   - Response parsing
   - Error handling

2. Integration Tests
   - Connection/disconnection cycle
   - Outbound call success flow
   - Inbound call acceptance flow
   - Call transfer
   - Call hold/resume
   - Health check
   - Connection pool behavior
   - Callback invocation
   - Concurrent call handling

3. Stress Tests
   - 100+ concurrent calls
   - Connection pool exhaustion
   - Network latency/packet loss
   - Server restart recovery
   - Rapid reconnection

4. Compatibility Tests
   - Cross-adapter call routing
   - Conference with mixed adapters
   - Transfer between adapter types
```

---

## 13. Metrics & Observability

Every adapter tracks:

```
Metrics Category          Key Metrics
─────────────────────────────────────────
Call Metrics              - Total attempts
                          - Success rate
                          - Failure reasons
                          - Average duration

Performance               - Connection latency (min/avg/max)
                          - Call setup time
                          - Message parsing time
                          - Pool utilization

Reliability               - Uptime %
                          - Connection recovery count
                          - Protocol error count
                          - Callback error count

Resource Usage            - Memory (MB)
                          - Open connections
                          - Queued messages
                          - CPU time
```

---

## 14. Dependency Injection

Adapter accepts injectable components:

```python
class SIPAdapterBase:
    def __init__(
        self,
        config: Dict[str, Any],
        logger: Optional[Logger] = None,
        event_emitter: Optional[EventEmitter] = None,
        connection_pool: Optional[ConnectionPool] = None,
        metrics_collector: Optional[MetricsCollector] = None
    ):
        pass
```

This enables:
- Custom logging backends
- Event bus integration
- Metrics pipeline (Prometheus, CloudWatch, etc.)
- Simplified testing with mocks

---

## 15. Version Compatibility

Adapter declares supported SIP server versions:

```python
class AsteriskAdapter(SIPAdapterBase):
    SUPPORTED_VERSIONS = {
        "asterisk": ["16.0.0", "17.x", "18.x", "19.x", "20.x"],
        "ami": ["1.3", "1.4"],
        "sip": ["2.0"]
    }

    def validate_server_version(self) -> bool:
        """Query server version on connect, verify compatibility."""
        pass
```

---

## Appendix A: Example Adapter Skeleton

```python
from abstract_adapter import SIPAdapterBase, CallStateEvent

class AsteriskAdapter(SIPAdapterBase):
    """Asterisk via AMI protocol."""

    adapter_type = "asterisk"

    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.ami_connection = None

    def connect(self, host: str, port: int, auth_config: Dict) -> bool:
        """Connect to Asterisk via AMI."""
        try:
            self.ami_connection = AMIClient(host, port, **auth_config)
            return True
        except Exception as e:
            self.emit_error(e)
            return False

    def make_call(self, from_number: str, to_number: str, **options) -> str:
        """Initiate call via Originate command."""
        call_id = self.generate_call_id()
        try:
            self.ami_connection.originate(
                channel=f"SIP/{from_number}",
                exten=to_number,
                context="default"
            )
            self.emit_event("call_state_changed", CallStateEvent(...))
            return call_id
        except Exception as e:
            raise CallError(f"Failed to originate call: {e}")
```

---

## Appendix B: Configuration Examples

### Asterisk Configuration

```yaml
type: asterisk
host: 192.168.1.100
port: 5038  # AMI port
auth:
  username: asterisk
  password: managerpassword
  realm: asterisk.local
timeout: 30
retry_count: 3
pool_size: 10
```

### FreeSWITCH Configuration

```yaml
type: freeswitch
host: 192.168.1.101
port: 8021  # ESL port
auth:
  username: n/a
  password: ClueCon  # Default FreeSWITCH password
  realm: freeswitch.local
timeout: 10
pool_size: 5
```

### OpenSIPS Configuration

```yaml
type: opensips
host: 192.168.1.102
port: 8888  # MI_JSON port
auth:
  username: admin
  password: admin_secret
  realm: opensips.local
timeout: 30
retry_count: 3
```

---

**Document Citation:** `if://doc/sip-adapter-pattern-v1-2025-11-11`
**Status:** Design Specification (Ready for Implementation)
**Next Phase:** Implementation phase (Agents 1-7 create concrete adapters)
