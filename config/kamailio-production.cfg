#!KAMAILIO
#
# InfraFabric SIP Proxy - PRODUCTION CONFIGURATION (IF.ESCALATE)
# ================================================================
#
# Philosophy Grounding:
# - Wu Lun (朋友): SIP peers are equals, external experts invited as peers
# - Popper Falsifiability: External experts provide contrarian views
# - IF.ground Observable: All SIP signaling is logged and auditable
# - IF.TTT: Traceable (X-IF-Trace-ID), Transparent (logs), Trustworthy (TLS+Auth)
#
# PRODUCTION SECURITY HARDENING:
# - TLS enabled (port 5061, TLSv1.2+)
# - SIP Digest Authentication required for all INVITE requests
# - Rate limiting: 10 calls/minute per external expert
# - IP allowlist: Only approved expert organization IPs
# - Enhanced IF.witness security logging
# - Defense in depth: Multiple security layers
#
# Integration:
# - IF.guard: Policy gate via Python hooks
# - IF.witness: Complete audit logging with security events
# - Session 3 (H.323): Route to H323_BRIDGE for Guardian council
# - Session 2 (WebRTC): Evidence sharing via DataChannel
#
# SPDX-License-Identifier: MIT
# Copyright (c) 2025 InfraFabric

####### Global Parameters #########

# --- Debugging (reduced for production) ---
debug=2
log_stderror=no
memdbg=5
memlog=5
log_facility=LOG_LOCAL0

# --- Network Settings ---
# Plain UDP/TCP disabled in production (use TLS only)
# listen=udp:0.0.0.0:5060
# listen=tcp:0.0.0.0:5060

# TLS ENABLED (PRODUCTION)
listen=tls:0.0.0.0:5061
# Optionally listen on specific interface for better security
# listen=tls:10.0.1.100:5061

# --- Process Settings ---
children=8
tcp_children=8
tcp_connection_lifetime=3605
tls_max_connections=2048

# --- DNS Settings ---
dns=no
rev_dns=no
use_dns_cache=on
use_dns_failover=on
dns_srv_loadbalancing=on

# --- Module Loading ---
loadmodule "tm.so"          # Transaction module
loadmodule "sl.so"          # Stateless replies
loadmodule "rr.so"          # Record-Route
loadmodule "pv.so"          # Pseudo-variables
loadmodule "maxfwd.so"      # Max-Forward header check
loadmodule "textops.so"     # Text operations
loadmodule "siputils.so"    # SIP utilities
loadmodule "xlog.so"        # Enhanced logging
loadmodule "sanity.so"      # SIP message sanity checks
loadmodule "app_python3.so" # Python 3 integration for IF.guard policy

# PRODUCTION SECURITY MODULES
loadmodule "tls.so"         # TLS/SSL support
loadmodule "auth.so"        # Authentication framework
loadmodule "auth_db.so"     # Database authentication
loadmodule "htable.so"      # Hash table for rate limiting
loadmodule "pike.so"        # Rate limiting per IP
loadmodule "permissions.so" # IP allowlist

# --- TLS Module Parameters (PRODUCTION) ---
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_method", "TLSv1.2+")
modparam("tls", "certificate", "/etc/kamailio/tls/server.pem")
modparam("tls", "private_key", "/etc/kamailio/tls/server-key.pem")
modparam("tls", "ca_list", "/etc/kamailio/tls/ca-list.pem")
modparam("tls", "verify_certificate", 1)
modparam("tls", "require_certificate", 0)  # Set to 1 for mutual TLS
modparam("tls", "verify_depth", 3)

# Strong cipher suites (TLSv1.2+ only, no weak ciphers)
modparam("tls", "cipher_list", "ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4")

# TLS session cache for performance
modparam("tls", "session_cache", 1)
modparam("tls", "session_id", "kamailio-if-escalate")
modparam("tls", "tls_log", 3)

# --- Authentication Module Parameters ---
modparam("auth", "nonce_expire", 300)      # 5 minutes
modparam("auth", "nonce_auth_max_drift", 30)
modparam("auth", "qop", "auth")            # Quality of Protection
modparam("auth", "auth_checks_register", 11)
modparam("auth", "auth_checks_no_dlg", 9)
modparam("auth", "auth_checks_in_dlg", 15)

# Database authentication (using SQLite for simplicity, use PostgreSQL in production)
modparam("auth_db", "db_url", "sqlite:///etc/kamailio/kamailio.db")
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")

# --- Rate Limiting Parameters (htable) ---
# Track calls per external expert: max 10 calls/minute
modparam("htable", "htable", "rate_limit=>size=10;autoexpire=60;")
modparam("htable", "htable", "auth_failures=>size=10;autoexpire=300;")

# --- Pike Module (IP-based rate limiting) ---
modparam("pike", "sampling_time_unit", 10)  # 10 seconds
modparam("pike", "reqs_density_per_unit", 30)  # Max 30 requests per 10 seconds per IP
modparam("pike", "remove_latency", 120)  # Remove entry after 2 minutes

# --- Permissions Module (IP Allowlist) ---
modparam("permissions", "db_url", "sqlite:///etc/kamailio/kamailio.db")
modparam("permissions", "db_mode", 1)  # Load from database
modparam("permissions", "address_table", "address")

# Alternatively, use file-based allowlist:
# modparam("permissions", "address_file", "/etc/kamailio/ip_allowlist.txt")

# --- Python Integration ---
modparam("app_python3", "load", "/home/user/infrafabric/src/communication/sip_proxy.py")
modparam("app_python3", "script_name", "sip_proxy")

# --- Transaction Module ---
modparam("tm", "fr_timer", 2000)
modparam("tm", "fr_inv_timer", 40000)
modparam("tm", "auto_inv_100_reason", "Trying")

# --- Record-Route Module ---
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# --- Sanity Checks ---
modparam("sanity", "default_checks", 1511)
modparam("sanity", "uri_checks", 3)

####### Routing Logic ########

# Main SIP request routing block
request_route {
    # SECURITY: Pike IP-based rate limiting (first line of defense)
    if (!pike_check_req()) {
        xlog("L_ALERT", "[SECURITY] Pike rate limit exceeded from $si:$sp\n");
        xlog("L_ALERT", "[IF.witness] SECURITY_EVENT: rate_limit_exceeded, source_ip=$si, method=$rm\n");
        sl_send_reply("503", "Service Unavailable - Rate Limit Exceeded");
        exit;
    }

    # SECURITY: IP Allowlist check
    route(IP_ALLOWLIST_CHECK);

    # Initial sanity checks
    route(SANITY_CHECK);

    # SECURITY: Verify TLS connection
    route(TLS_VERIFY);

    # IF.witness logging: Log all incoming requests with security context
    xlog("L_INFO", "[IF.witness] SIP $rm from $fu to $ru (Call-ID: $ci, TLS: $pr, Source: $si:$sp)\n");

    # Max-Forward check (loop prevention)
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_WARN", "[SECURITY] Max-Forward exceeded from $si:$sp\n");
        xlog("L_WARN", "[IF.witness] SECURITY_EVENT: max_forward_exceeded, source=$si\n");
        sl_send_reply("483", "Too Many Hops");
        exit;
    }

    # SECURITY: Authentication required for INVITE
    if (is_method("INVITE")) {
        route(AUTHENTICATION);
        route(IF_ESCALATE_INVITE);
    }

    # Handle in-dialog requests
    if (has_totag()) {
        route(IN_DIALOG);
    }

    # Record-Route for all requests
    if (!is_method("REGISTER")) {
        record_route();
    }

    # Forward to destination
    route(FORWARD);
}

# SECURITY: IP Allowlist Check
route[IP_ALLOWLIST_CHECK] {
    # Check if source IP is in allowlist
    if (!allow_source_address()) {
        xlog("L_ALERT", "[SECURITY] IP not in allowlist: $si:$sp\n");
        xlog("L_ALERT", "[IF.witness] SECURITY_EVENT: ip_not_allowlisted, source_ip=$si, method=$rm, from=$fu\n");
        sl_send_reply("403", "Forbidden - IP Not Allowlisted");
        exit;
    }

    xlog("L_INFO", "[SECURITY] IP allowlist check passed: $si\n");
}

# SECURITY: TLS Verification
route[TLS_VERIFY] {
    # Verify TLS is used (no plaintext SIP in production)
    if ($pr != "tls") {
        xlog("L_ALERT", "[SECURITY] Non-TLS connection attempt from $si:$sp (protocol: $pr)\n");
        xlog("L_ALERT", "[IF.witness] SECURITY_EVENT: non_tls_connection, source_ip=$si, protocol=$pr\n");
        sl_send_reply("403", "Forbidden - TLS Required");
        exit;
    }

    # Log TLS connection details
    xlog("L_INFO", "[SECURITY] TLS connection: version=$tls_version, cipher=$tls_cipher\n");
    xlog("L_INFO", "[IF.witness] TLS_CONNECTION: version=$tls_version, cipher=$tls_cipher, peer=$tls_peer_subject\n");

    # Optional: Verify client certificate if mutual TLS is enabled
    # if ($tls_peer_verified != "1") {
    #     xlog("L_ALERT", "[SECURITY] Client certificate verification failed: $si\n");
    #     sl_send_reply("403", "Forbidden - Invalid Certificate");
    #     exit;
    # }
}

# SECURITY: SIP Digest Authentication
route[AUTHENTICATION] {
    # Check if request is authenticated
    if (!is_method("INVITE")) {
        return;
    }

    # Check for Authorization header
    if ($au == $null) {
        xlog("L_INFO", "[SECURITY] No credentials provided, challenging: $fu\n");
        xlog("L_INFO", "[IF.witness] AUTH_CHALLENGE: from=$fu, to=$ru, call_id=$ci\n");
        auth_challenge("external.advisor", "0");
        exit;
    }

    # Verify credentials against database
    if (!auth_check("$fd", "subscriber", "1")) {
        xlog("L_WARN", "[SECURITY] Authentication failed for $fu from $si\n");
        xlog("L_WARN", "[IF.witness] SECURITY_EVENT: auth_failed, from=$fu, source_ip=$si, attempts=$sht(auth_failures=>$au)\n");

        # Track authentication failures
        $sht(auth_failures=>$au) = $sht(auth_failures=>$au) + 1;

        # Block after 5 failed attempts
        if ($sht(auth_failures=>$au) > 5) {
            xlog("L_ALERT", "[SECURITY] Too many auth failures for $au, blocking\n");
            xlog("L_ALERT", "[IF.witness] SECURITY_EVENT: auth_blocked, user=$au, failures=$sht(auth_failures=>$au)\n");
            sl_send_reply("403", "Forbidden - Too Many Failed Attempts");
            exit;
        }

        auth_challenge("$fd", "0");
        exit;
    }

    # Authentication successful
    xlog("L_INFO", "[SECURITY] Authentication successful for $au from $si\n");
    xlog("L_INFO", "[IF.witness] AUTH_SUCCESS: user=$au, from=$fu, source_ip=$si\n");

    # Reset failure counter
    $sht(auth_failures=>$au) = 0;
}

# SECURITY: Rate Limiting per Expert
route[RATE_LIMIT_CHECK] {
    # Extract expert ID from From header
    $var(expert_id) = $fU;  # From username

    # Get current call count for this expert
    $var(call_count) = $sht(rate_limit=>$var(expert_id));

    if ($var(call_count) == $null) {
        $var(call_count) = 0;
    }

    xlog("L_INFO", "[SECURITY] Rate limit check: expert=$var(expert_id), current_calls=$var(call_count)\n");

    # Check if rate limit exceeded (10 calls/minute)
    if ($var(call_count) >= 10) {
        xlog("L_ALERT", "[SECURITY] Rate limit exceeded for expert $var(expert_id): $var(call_count) calls/min\n");
        xlog("L_ALERT", "[IF.witness] SECURITY_EVENT: rate_limit_exceeded, expert=$var(expert_id), calls=$var(call_count)\n");
        sl_send_reply("429", "Too Many Requests - Rate Limit Exceeded");
        exit;
    }

    # Increment call counter (expires after 60 seconds via htable autoexpire)
    $sht(rate_limit=>$var(expert_id)) = $var(call_count) + 1;

    xlog("L_INFO", "[SECURITY] Rate limit OK: expert=$var(expert_id), calls=$sht(rate_limit=>$var(expert_id))/10\n");
}

# IF.ESCALATE INVITE handling
route[IF_ESCALATE_INVITE] {
    xlog("L_INFO", "[IF.ESCALATE] Processing INVITE from $fu to $ru\n");

    # SECURITY: Rate limiting check
    route(RATE_LIMIT_CHECK);

    # Extract custom IF headers
    $var(trace_id) = $hdr(X-IF-Trace-ID);
    $var(hazard) = $hdr(X-IF-Hazard);
    $var(signature) = $hdr(X-IF-Signature);

    # Validate required IF headers
    if (!$var(trace_id) || !$var(hazard)) {
        xlog("L_WARN", "[IF.ESCALATE] Missing required IF headers (X-IF-Trace-ID or X-IF-Hazard)\n");
        xlog("L_WARN", "[IF.witness] SECURITY_EVENT: missing_if_headers, from=$fu, source_ip=$si\n");
        sl_send_reply("400", "Bad Request - Missing IF headers");
        exit;
    }

    # SECURITY: Log all IF header values for audit
    xlog("L_INFO", "[IF.witness] IF_HEADERS: trace_id=$var(trace_id), hazard=$var(hazard), signature=$var(signature), user=$au\n");

    xlog("L_INFO", "[IF.guard] Checking policy: trace_id=$var(trace_id), hazard=$var(hazard), expert=$au\n");

    # Call Python hook for IF.guard policy check (includes security validation)
    if (!python_exec("check_policy")) {
        xlog("L_WARN", "[IF.guard] Policy REJECTED: trace_id=$var(trace_id), expert=$au\n");
        xlog("L_WARN", "[IF.witness] SECURITY_EVENT: policy_rejected, trace_id=$var(trace_id), expert=$au, hazard=$var(hazard)\n");
        sl_send_reply("403", "Forbidden - IF.guard policy rejected");
        exit;
    }

    xlog("L_INFO", "[IF.guard] Policy APPROVED: trace_id=$var(trace_id), expert=$au\n");
    xlog("L_INFO", "[IF.witness] POLICY_APPROVED: trace_id=$var(trace_id), expert=$au, hazard=$var(hazard)\n");

    # Check if destination is external expert
    if ($ru =~ "sip:expert-.*@external.advisor") {
        xlog("L_INFO", "[IF.ESCALATE] Routing to external expert: $ru\n");
        route(EXTERNAL_EXPERT);
        exit;
    }

    # Route to H.323 gateway for Guardian council bridge
    route(H323_BRIDGE);
}

# External expert routing
route[EXTERNAL_EXPERT] {
    xlog("L_INFO", "[EXTERNAL] Routing to external expert: $ru\n");

    # Add Record-Route with custom parameters for IF.witness
    record_route_preset("0.0.0.0:5061;transport=tls", "trace=$var(trace_id)");

    # SECURITY: Add security context to IF.witness log
    xlog("L_INFO", "[IF.witness] EXTERNAL_CALL: expert=$ru, trace=$var(trace_id), tls_cipher=$tls_cipher, authenticated_user=$au\n");

    # Forward to external expert
    # In production, this would route to actual external SIP infrastructure
    t_relay();
}

# H.323 Gateway bridge (Session 3 integration)
route[H323_BRIDGE] {
    xlog("L_INFO", "[H323_BRIDGE] Routing to H.323 Gateway for Guardian council\n");

    # Rewrite Request-URI to H.323 gateway endpoint
    # In production, this would be the actual H.323 gateway IP:port
    $ru = "sip:h323-gateway@127.0.0.1:5062";

    # Add custom header for H.323 gateway to identify source
    append_hf("X-IF-Source: SIP-External-Expert\r\n");
    append_hf("X-IF-Bridge-Mode: SIP-to-H323\r\n");
    append_hf("X-IF-Authenticated-User: $au\r\n");

    # SECURITY: Log H.323 bridge routing with security context
    xlog("L_INFO", "[IF.witness] H323_BRIDGE: trace=$var(trace_id), expert=$au, tls_verified=yes\n");

    # Forward to H.323 gateway
    t_relay();
}

# In-dialog request handling
route[IN_DIALOG] {
    # Handle sequential requests within dialog
    if (!loose_route()) {
        if (is_method("ACK")) {
            if (t_check_trans()) {
                route(FORWARD);
                exit;
            } else {
                # ACK without matching transaction - ignore and discard
                exit;
            }
        }
        sl_send_reply("404", "Not here");
        exit;
    }

    # SECURITY: Verify in-dialog requests are still authenticated
    if (is_method("BYE|UPDATE|INFO")) {
        xlog("L_INFO", "[IF.witness] IN_DIALOG: method=$rm, call_id=$ci, user=$au\n");
    }

    route(FORWARD);
}

# Forward request
route[FORWARD] {
    if (!t_relay()) {
        sl_reply_error();
    }
}

# Sanity checks
route[SANITY_CHECK] {
    if (!sanity_check()) {
        xlog("L_WARN", "[SANITY] Malformed SIP message from $si:$sp\n");
        xlog("L_WARN", "[IF.witness] SECURITY_EVENT: malformed_message, source_ip=$si, method=$rm\n");
        exit;
    }
}

####### Response Handling ########

onreply_route {
    # IF.witness: Log all responses with security context
    xlog("L_INFO", "[IF.witness] SIP response $rs $rr (Call-ID: $ci, TLS: $pr)\n");

    # Handle specific response codes
    if (status =~ "^[12][0-9][0-9]$") {
        # Success responses (1xx, 2xx)
        xlog("L_INFO", "[IF.ESCALATE] Success response: $rs $rr\n");
    } else if (status =~ "^[4-6][0-9][0-9]$") {
        # Error responses (4xx, 5xx, 6xx)
        xlog("L_WARN", "[IF.ESCALATE] Error response: $rs $rr\n");
        xlog("L_WARN", "[IF.witness] ERROR_RESPONSE: status=$rs, reason=$rr, call_id=$ci\n");
    }
}

####### Failure Handling ########

failure_route {
    xlog("L_WARN", "[FAILURE] Transaction failed: $ci\n");

    # SECURITY: Log failure with security context
    xlog("L_WARN", "[IF.witness] CALL_FAILED: trace=$hdr(X-IF-Trace-ID), call_id=$ci, expert=$au, reason=$T_reply_reason\n");

    # Could implement retry logic here in production
    # For now, just log and fail
}

####### Production Security Notes ########

# TLS Configuration (/etc/kamailio/tls.cfg):
# ------------------------------------------
# [server:default]
# method = TLSv1.2+
# verify_certificate = yes
# require_certificate = no
# private_key = /etc/kamailio/tls/server-key.pem
# certificate = /etc/kamailio/tls/server.pem
# ca_list = /etc/kamailio/tls/ca-list.pem
# cipher_list = ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256
#
# [client:default]
# method = TLSv1.2+
# verify_certificate = yes
# require_certificate = no

# IP Allowlist (database table 'address'):
# -----------------------------------------
# Approved external expert organizations:
#   - 203.0.113.0/24    (Example Safety Org)
#   - 198.51.100.0/24   (Example Ethics Institute)
#   - 192.0.2.0/24      (Example Security Consultancy)
#
# INSERT INTO address (grp, ip_addr, mask, port, proto, tag)
# VALUES (1, '203.0.113.0', 24, 0, 'any', 'safety-org');
#
# INSERT INTO address (grp, ip_addr, mask, port, proto, tag)
# VALUES (1, '198.51.100.0', 24, 0, 'any', 'ethics-institute');
#
# INSERT INTO address (grp, ip_addr, mask, port, proto, tag)
# VALUES (1, '192.0.2.0', 24, 0, 'any', 'security-consultancy');

# SIP Digest Authentication (database table 'subscriber'):
# ---------------------------------------------------------
# CREATE TABLE subscriber (
#   id INTEGER PRIMARY KEY,
#   username VARCHAR(64) NOT NULL,
#   domain VARCHAR(64) NOT NULL,
#   password VARCHAR(128) NOT NULL,
#   ha1 VARCHAR(128),
#   ha1b VARCHAR(128)
# );
#
# Example users (password stored as HA1 hash):
# INSERT INTO subscriber (username, domain, password)
# VALUES ('expert-safety', 'external.advisor', 'ha1_hash_here');

# Security Monitoring:
# --------------------
# All security events are logged to IF.witness with tags:
#   - SECURITY_EVENT: Security violations (rate limit, auth failures, etc.)
#   - AUTH_CHALLENGE: Authentication challenges sent
#   - AUTH_SUCCESS: Successful authentication
#   - AUTH_FAILED: Failed authentication attempts
#   - POLICY_APPROVED: IF.guard policy approval
#   - POLICY_REJECTED: IF.guard policy rejection
#   - TLS_CONNECTION: TLS connection details
#   - EXTERNAL_CALL: External expert call established
#   - H323_BRIDGE: H.323 bridge routing
#
# Monitor these logs for security incidents and anomalies.

# Rate Limiting Summary:
# ----------------------
# - Pike module: Max 30 requests/10 seconds per IP (DDoS protection)
# - htable rate_limit: Max 10 calls/minute per expert (business logic)
# - Both limits are enforced before routing logic

# Defense in Depth Layers:
# ------------------------
# Layer 1: IP Allowlist (only approved organizations)
# Layer 2: Pike rate limiting (anti-DDoS)
# Layer 3: TLS verification (encrypted transport)
# Layer 4: SIP Digest Authentication (user authentication)
# Layer 5: Per-expert rate limiting (abuse prevention)
# Layer 6: IF.guard policy (business logic validation)
# Layer 7: IF.witness logging (audit and forensics)
